Program.Sub.Preflight.Start
V.Global.sLogging.Declare(String, "")
Program.External.include.Library("450100.lib")
Program.Sub.Preflight.End

Program.Sub.Main.Start
F.Intrinsic.Control.Try
'TJS, October 2023
'Customer: Podmore Manufacturing
'Quote: 14354
'Podmore Manufacturing Inc. uses an Autocrib cloud tooling service that auto-issues materials to
'work orders using ARC 6025. It currently works well, but Autocrib will be moving their services to a
'cloud platform that cannot support storing special characters such as *, $, or % in their tables.
'Currently, ARC 6025 and Podmore’s Barcode Work Order report use all these characters either in
'part numbers or as prefixes to work orders.

	'Customer: Podmore Manufacturing
	'Developer: FEQ (Sisco)
	'Date: 6/16/2020
	'This project will run from the online update. 
	'The purpose of this project is to issue material into a work order from a csv created by Tool Crib.
	'The file will be located in folder Global\Custom\Autocrib. This script will grab the file anytime it is executed and process the issue material.
	'The file generated by Tool Crib has the following columns:
	'
	'Part #
	'Description
	'Issue Date
	'Issue Time
	'Employee Number
	'JobSuffSeq
	'(Blank column)
	'(Blank column)
	'Qty
	'Lot
	'
	'This project uses Callwrapper 450100 to issue material, which uses a comma delimited file in the following format:
	'
	'Part Length(20)
	'Rev Length(03)
	'Location Length(02)
	'Quantity Length(16)
	'Lot Length(15)
	'Bin Length(06)
	'Heat Length(15)
	'Serial Length(30)
	'Workorder Number Length(6)
	'Workorder Suffix Length(3)
	'Workorder Sequence Length(6)
	'
	'We will be using the library 450100.lib to aid with the Issue Material process
	'
	'The customer did not want to have the process close the work order sequence, so we are expecting the user to have company option "Manual Close Only On Material Sequence"
	'Design/wise, basing it off some programs we have, the project will verify/create directories within the Global directory to use these to process and report errors.
	'The project will run off hook 38130 (Post online update hook)

''Testing stuff
'Function.Intrinsic.Debug.InvokeDebugger
'Function.Intrinsic.Debug.Stop

'			V.Local.sFileName.Declare(String, "LPLA014MOPEN.txt")
'			F.Global.General.CallWrapperSync(450100,V.Local.sFileName)

'Function.Intrinsic.Debug.Stop

F.Intrinsic.Control.CallSub(VerifyDirectories)
F.Intrinsic.Control.CallSub(ProcessFiles)
F.Intrinsic.Control.CallSub(Unload)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndTry
Program.Sub.Main.End

Program.Sub.Unload.Start
F.Intrinsic.Control.Try
V.Local.sFileLog.Declare(String, "")

F.Intrinsic.String.Build("IssueMaterialLog{0}.txt", V.Ambient.Now, V.Local.sFileLog)
F.Intrinsic.File.MakeFilenameFriendly(V.Local.sFileLog, V.Local.sFileLog)
F.Intrinsic.String.Build("{0}\Custom\Autocrib\Logs\{1}", V.Caller.GlobalDir, V.Local.sFileLog, V.Local.sFileLog)

F.Intrinsic.File.String2File(V.Local.sFileLog, V.Global.sLogging)

F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndTry
Program.Sub.Unload.End

Program.Sub.VerifyDirectories.Start
F.Intrinsic.Control.Try
V.Local.sDirectory.Declare(String, "")
V.Local.bCheck.Declare(Boolean, False)

V.Global.sLogging.Set("Verifying directories...")

'We are going to verify that the appropriate directories exists in the Global directory
F.Intrinsic.String.Build("{0}\Custom\Autocrib\", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.DirExists(V.Local.sDirectory, V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck, =, False)
	F.Intrinsic.File.CreateDir(V.Local.sDirectory)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Custom\Autocrib\Processing", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.DirExists(V.Local.sDirectory, V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck, =, False)
	F.Intrinsic.File.CreateDir(V.Local.sDirectory)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Custom\Autocrib\Completed", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.DirExists(V.Local.sDirectory, V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck, =, False)
	F.Intrinsic.File.CreateDir(V.Local.sDirectory)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Custom\Autocrib\Logs", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.DirExists(V.Local.sDirectory, V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck, =, False)
	F.Intrinsic.File.CreateDir(V.Local.sDirectory)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Custom\Autocrib\Errors", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.DirExists(V.Local.sDirectory, V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck, =, False)
	F.Intrinsic.File.CreateDir(V.Local.sDirectory)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine)
F.Intrinsic.Control.EndTry
Program.Sub.VerifyDirectories.End

Program.Sub.ProcessFiles.Start
F.Intrinsic.Control.Try
V.Local.sDirectory.Declare(String, "")
V.Local.sFiles.Declare(String, "")
V.Local.sCheck.Declare(String, "")
V.Local.sDestination.Declare(String, "")
V.Local.sNew.Declare(String, "")
V.Local.iFiles.Declare(Long, 0)

'The files will be dropped in the Global\custom\autocrib folder. We want to read in all available files and process them. To do so, we want to copy/delete files from different directories within the path.
F.Intrinsic.String.Build("{0}{1}{1}Reading files from {2}\Custom\Autocrib directory..", V.Global.sLogging, V.Ambient.NewLine, V.Caller.GlobalDir, V.Global.sLogging)

F.Intrinsic.String.Build("{0}\Custom\Autocrib\", V.Caller.GlobalDir, V.Local.sDirectory)
F.Intrinsic.File.GetFileList(V.Local.sDirectory, V.Local.sFiles)

F.Intrinsic.Control.If(V.Local.sFiles, <>, "")

	F.Intrinsic.String.Split(V.Local.sFiles, ":", V.Local.sFiles)
	F.Intrinsic.Math.Add(V.Local.sFiles.UBound, 1, V.Local.iFiles)
	F.Intrinsic.String.Build("{0}{1}{1}{2} file(s) found.", V.Global.sLogging, V.Ambient.NewLine, V.Local.iFiles, V.Global.sLogging)
	
	F.Intrinsic.Control.For(V.Local.iFiles, 0, V.Local.sFiles.UBound, 1)
		'We want to read the file contents and move the file to the Processing directory
		F.Intrinsic.String.Build("{0}\Custom\Autocrib\{1}", V.Caller.GlobalDir, V.Local.sFiles(V.Local.iFiles).Trim, V.Local.sDirectory)
		F.Intrinsic.String.Split(V.Local.sFiles(V.Local.iFiles).Trim, ".", V.Local.sCheck)
		F.Intrinsic.Control.If(V.Local.sCheck(V.Local.sCheck.UBound).UCase, <>, "CSV")
			'Incorrect filetype. Move to error log and delete
			F.Intrinsic.String.Build("{0}{1}{1}Incorrect filetype for {2}.", V.Global.sLogging, V.Ambient.NewLine, V.Local.sFiles(V.Local.iFiles).Trim, V.Global.sLogging)
			F.Intrinsic.String.Build("{0}\Custom\Autocrib\Errors\Incorrect_Filetype_{1}", V.Caller.GlobalDir, V.Local.sFiles(V.Local.iFiles).Trim, V.Local.sDestination)
			F.Intrinsic.String.StripCharacters(V.Ambient.Now, V.Local.sNew)
			F.Intrinsic.File.MakeFilenameFriendly(V.Local.sNew, V.Local.sNew)
			F.Intrinsic.String.Build("{0}.csv", V.Local.sNew, V.Local.sNew)
			F.Intrinsic.String.Replace(V.Local.sDestination, ".csv", V.Local.sNew, V.Local.sDestination)
			F.Intrinsic.File.CopyFile(V.Local.sDirectory, V.Local.sDestination)
			F.Intrinsic.File.DeleteFile(V.Local.sDirectory)
			
		F.Intrinsic.Control.Else
			'File is good. Parse it and process it.
			F.Intrinsic.String.Build("{0}{1}{1}Parsing file {2}...{1}{1}", V.Global.sLogging, V.Ambient.NewLine, V.Local.sFiles(V.Local.iFiles).Trim, V.Global.sLogging)
			F.Intrinsic.String.Build("{0}\Custom\Autocrib\Processing\{1}", V.Caller.GlobalDir, V.Local.sFiles(V.Local.iFiles).Trim, V.Local.sDestination)
			F.Intrinsic.String.StripCharacters(V.Ambient.Now, V.Local.sNew)
			F.Intrinsic.File.MakeFilenameFriendly(V.Local.sNew, V.Local.sNew)
			F.Intrinsic.String.Build("{0}.csv", V.Local.sNew, V.Local.sNew)
			F.Intrinsic.String.Replace(V.Local.sDestination, ".csv", V.Local.sNew, V.Local.sDestination)
			F.Intrinsic.File.CopyFile(V.Local.sDirectory, V.Local.sDestination)
			F.Intrinsic.File.DeleteFile(V.Local.sDirectory)
			
			F.Intrinsic.Control.CallSub(IssueMaterial, "FILE", V.Local.sDestination)
			
		F.Intrinsic.Control.EndIf
		
	F.Intrinsic.Control.Next(V.Local.iFiles)
F.Intrinsic.Control.Else
	'No Files Found
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine)
F.Intrinsic.Control.EndTry
Program.Sub.ProcessFiles.End

Program.Sub.IssueMaterial.Start
F.Intrinsic.Control.Try
V.Local.bCheck.Declare(Boolean, False)
V.Local.sContents.Declare(String, "")
V.Local.sLine.Declare(String, "")
V.Local.sPart.Declare(String, "")
V.Local.sRev.Declare(String, "")
V.Local.sLot.Declare(String, "")
V.Local.sSql.Declare(String, "")
V.Local.sRet.Declare(String, "")
V.Local.sJob.Declare(String, "")
V.Local.sSuff.Declare(String, "")
V.Local.sSeq.Declare(String, "")
V.Local.sEmpNo.Declare(String, "")
V.Local.sIssue.Declare(String, "")
V.Local.sDateSeq.Declare(String, "")
V.Local.sFilePath.Declare(String, "")
V.Local.sDateHist.Declare(String, "")
V.Local.sTimeHist.Declare(String, "")
V.Local.fQty.Declare(Float, 0.00)
V.Local.iLines.Declare(Long, 0)
V.Local.sReturn.Declare(String, "")

'we are expecting to have 10 columns in the csv file. 
'Part #
'Description
'Issue Date
'Issue Time
'Employee Number
'JobSuffSeq
'(Blank column)
'(Blank column)
'Qty
'Lot

'The file/location are passed in the FILE arg
F.Intrinsic.Variable.ArgExists("FILE", V.Local.bCheck)
F.Intrinsic.Control.If(V.Local.bCheck)
	
	F.ODBC.Connection!conx.OpenCompanyConnection
	
	F.Intrinsic.File.File2String(V.Args.FILE, V.Local.sContents)
	F.Intrinsic.String.Split(V.Local.sContents, V.Ambient.NewLine, V.Local.sContents)
	F.Intrinsic.Control.For(V.Local.iLines, 0, V.Local.sContents.UBound, 1)
		F.Intrinsic.String.Split(V.Local.sContents(V.Local.iLines), ",", V.Local.sLine)
		V.Local.sLine.RedimPreserve(0, 9)
		
		F.Intrinsic.Control.If(V.Local.sLine(0).Trim, <>, "")
			'Part is in the first column
			F.Intrinsic.String.RPad(V.Local.sLine(0).Trim, " ", 20, V.Local.sPart)
			F.Intrinsic.String.Right(V.Local.sPart, 3, V.Local.sRev)
			'TJS - Part numbers in Arcturus (Autocrib) have an "X" in the place of an "*" these need to be replaced before uploading to GSS
			F.Intrinsic.String.Replace(V.Local.sPart,"X","*",V.Local.sPart)
			
			'Checking to see if there is a Lot number, if there is not a lot number than the user has specified that this line is for Receiving material to the Autocrib, which has already been accounted for in GSS  
			F.Intrinsic.Control.If(V.Local.sLine(9),<>,"")
				
				'Lot is in the 9th position. We need that to get the rest of the part information
				F.Intrinsic.String.Build("Select TOP 1 LOCATION, LOT, BIN, HEAT from V_ITEM_MASTER where PART = '{0}' and LOT = '{1}'", V.Local.sPart.Trim, V.Local.sLine(9).Trim, V.Local.sSql)
				F.ODBC.Connection!conx.ExecuteAndReturn(V.Local.sSql, V.Local.sRet)
				F.Intrinsic.String.Split(V.Local.sRet, "*!*", V.Local.sRet)
				V.Local.sRet.RedimPreserve(0,3)
				
				'Quantity is in 8th location
				V.Local.fQty.Set(V.Local.sLine(8).Float)
				F.Intrinsic.String.Format(V.Local.fQty,"########.0000",V.Local.sIssue)
								
				'Job/Suffix/Sequence is in the 5th place, but since scanned, it contains $%
				'TJS - The $% has been removed from the Barcode WO Router and will no longer be scanned in as Arcturus cannot handle these symbols
				'F.Intrinsic.String.Build("***{0}", V.Local.sLine(5).Trim, V.Local.sLine(5))
				'F.Intrinsic.String.Replace(V.Local.sLine(5).trim, "***$%", "", V.Local.sLine(5))
				'TJS - Podmore does not use job suffixes in Arcturus.  Instead, jobs will come in as JOB-SEQUENCE.  We need to replace the dash (-) with three spaces
				F.Intrinsic.String.IsInString(V.Local.sLine(5),"-",True,V.Local.bCheck)
				F.Intrinsic.Control.If(V.Local.bCheck)
					F.Intrinsic.String.Replace(V.Local.sLine(5).Trim,"-","   ",V.Local.sLine(5))
				F.Intrinsic.Control.EndIf
							
				F.Intrinsic.String.RPad(V.Local.sLine(5), " ", 15, V.Local.sLine(5))
				F.Intrinsic.String.Left(V.Local.sLine(5), 6, V.Local.sJob)
				F.Intrinsic.String.Right(V.Local.sLine(5), 9, V.Local.sLine(5))
				F.Intrinsic.String.Left(V.Local.sLine(5), 3, V.Local.sSuff)
				F.Intrinsic.String.Right(V.Local.sLine(5), 6, V.Local.sSeq)
				F.Intrinsic.String.Build("{0}{1}Issuing material for Job {2} {3} {4}.", V.Global.sLogging, V.Ambient.NewLine, V.Local.sJob, V.Local.sSuff, V.Local.sSeq, V.Global.sLogging)
				
				'check for LOT quantity > 0
				F.Intrinsic.String.Build("Select QUANTITY from V_ITEM_MASTER where PART = '{0}' and LOT = '{1}'", V.Local.sPart.Trim, V.Local.sLine(9).Trim, V.Local.sSql)
				F.ODBC.Connection!conx.ExecuteAndReturn(V.Local.sSql, V.Local.sReturn)
				F.Intrinsic.Control.If(V.local.sReturn.Long,>,0)
				
					
					F.Data.DataTable.AddRow("450100", "Part", V.Local.sPart.Trim, "Rev", V.Local.sRev, "Location", V.Local.sRet(0).Trim, "Quantity", V.Local.sIssue, "Lot", V.Local.sRet(1).Trim, "Bin", V.Local.sRet(2).Trim, "Heat", V.Local.sRet(3).Trim, "WONumber", V.Local.sJob, "WOSuffix", V.Local.sSuff, "WOSeq", V.Local.sSeq)
					
					F.Intrinsic.Control.CallSub(450100Sync)
					
					
					'Replace the user and create date in Job Detail
					F.Intrinsic.String.Build("Select EMPL, DATE_LAST_CHG from JOB_DETAIL where JOB = '{0}' and SUFFIX = '{1}' and SEQ = '{2}' order by date_sequence desc, sequence_key desc", V.Local.sJob, V.Local.sSuff, V.Local.sSeq, V.Local.sSql)
					F.ODBC.Connection!conx.OpenLocalRecordsetRW("rstJobDeets", V.Local.sSql)
					
					F.Intrinsic.Control.If(V.ODBC.conx!rstJobDeets.EOF, =, False)
						F.Intrinsic.String.Build("{0}{1}Updating Employee and Date in Issue Material sequence.{1}", V.Global.sLogging, V.Ambient.NewLine, V.Global.sLogging)
						
						'Date Sequence is in the 2nd position
						F.Intrinsic.String.Format(V.Local.sLine(2).Trim, "YYYYMMDD", V.Local.sDateSeq)
						
						'Employee number is in the 4th place and needs to be padded
						F.Intrinsic.String.LPad(V.Local.sLine(4).Trim, "0", 5, V.Local.sEmpNo)
						
						F.ODBC.conx!rstJobDeets.Set!EMPL(V.Local.sEmpNo)
						F.ODBC.conx!rstJobDeets.Set!DATE_LAST_CHG(V.Local.sDateSeq)
						F.ODBC.conx!rstJobDeets.Update
						
						'Replace the user and create date in Job Detail
						F.Intrinsic.String.Build("Select USERID from INVENTORY_HIST where PART = '{0}' and JOB = '{1}' and SUFFIX = '{2}' and SEQ = '{3}' order by DATE_HISTORY desc, INV_HIST_TIME desc", V.Local.sPart.Trim, V.Local.sJob, V.Local.sSuff, V.Local.sSeq, V.Local.sSql)
		
						F.ODBC.Connection!conx.ExecuteAndReturn(V.Local.sSQL,V.Local.sSQL)
						F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF)
							F.Intrinsic.String.Build("{0}{1}Inventory History record was not found. User name for entry not updated.{1}", V.Global.sLogging, V.Ambient.NewLine, V.Global.sLogging)
					
						F.Intrinsic.Control.Else
							F.Intrinsic.String.Build("update INVENTORY_HIST set USERID = '{0}' where PART = '{1}' and JOB = '{2}' and SUFFIX = '{3}' and SEQ = '{4}'",V.Local.sEmpNo,V.Local.sPart.Trim, V.Local.sJob, V.Local.sSuff, V.Local.sSeq, V.Local.sSql)
							F.ODBC.Connection!conx.Execute(V.Local.sSQL)
						F.Intrinsic.Control.EndIf
						
						
					F.Intrinsic.Control.Else
						F.Intrinsic.String.Build("{0}{1}Issue material sequence not found. Employee and date not updated.{1}", V.Global.sLogging, V.Ambient.NewLine, V.Global.sLogging)
						
					F.Intrinsic.Control.EndIf
					
					F.ODBC.conx!rstJobDeets.Close
				F.Intrinsic.Control.Else
					F.Intrinsic.String.Build("{0}{1}{2} QTY_ONHAND was zero Issue material Not Attempted.{1}", V.Global.sLogging, V.Ambient.NewLine, V.Local.sLine(0).Trim, V.Global.sLogging)
					
				F.Intrinsic.Control.Endif
			F.Intrinsic.Control.Else
				F.Intrinsic.String.Build("{0}{1}**No LOT found, Possible Cause AutoCrib received material:{1}{2} and has not been issued to a job yet.{1}", V.Global.sLogging, V.Ambient.NewLine, V.Local.sLine(0).Trim, V.Global.sLogging)
				
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
		
	F.Intrinsic.Control.Next(V.Local.iLines)
	
	F.ODBC.Connection!conx.Close
	
	F.Intrinsic.String.Replace(V.Args.FILE, "\Processing\", "\Completed\", V.Local.sFilePath)
	F.Intrinsic.String.Build("{0}{2}File {1} has been processed.{2}{2}", V.Global.sLogging, V.Local.sFilePath, V.Ambient.NewLine, V.Global.sLogging)
	F.Intrinsic.File.CopyFile(V.Args.FILE, V.Local.sFilePath)
	F.Intrinsic.File.DeleteFile(V.Args.FILE)
	
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.String.Replace(V.Args.FILE, "\Processing\", "\Errors\", V.Local.sFilePath)
	F.Intrinsic.String.Build("{0}{2}Error processing the Issue Material for information in file {1}.{2}{2}Description:{2}{3}", V.Global.sLogging, V.Local.sFilePath, V.Ambient.NewLine,v.Ambient.ErrorDescription, V.Global.sLogging)
	F.Intrinsic.File.CopyFile(V.Args.FILE, V.Local.sFilePath)
	F.Intrinsic.File.DeleteFile(V.Args.FILE)
	F.ODBC.Connection!conx.Close
'	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine)
F.Intrinsic.Control.EndTry
Program.Sub.IssueMaterial.End

Program.Sub.Error.Start
F.Intrinsic.Control.Try
V.Local.sError.Declare(String, "")

F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}", V.Caller.ScriptFile, V.Ambient.Newline, V.Args.Subroutine, V.Ambient.ErrorNumber, V.Ambient.ErrorDescription, V.Ambient.GABVersion, V.Local.sError)

F.Intrinsic.Control.Callsub(Unload)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndTry
Program.Sub.Error.End

Program.Sub.Logging.Start

Program.Sub.Logging.End

Program.Sub.Comments.Start
${$5$}$2.0.0.0$}$2
${$6$}$tsmith$}$20231020131555420$}$xqPbj9atw05FglvzeFsZ9cqXP+qvG6tXogyNU15s3mtbZJSzlQhcIec7iJ9zG+pPVfL/rnpF0lY=
Program.Sub.Comments.End